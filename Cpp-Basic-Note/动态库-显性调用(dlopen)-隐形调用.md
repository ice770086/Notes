# 动态库-显性调用(dlopen)-隐形调用

**在linux环境下编程，我们如果想要使用第三方的库，基本上有以下几种方式：**

1. 将第三方库的源码合并到我们的工程项目代码中，一起编译。
2. 将第三方库编译成静态库(xxx.a),我们在使用时，在Makefile中引用该静态库。
3. 将第三方库编译成动态库(xxx.so), 我们在使用时，隐性调用该动态库，具体表现为需要 在程序中包含动态库的 头文件，同时需要在/usr/lib路径下，存放动态库文件，以便程序调用。
4. 将第三方库编译成动态库(xxx.so)， 我们在使用时，显性调用该动态库，在程序中，不需要包含动态库的头文件，使用 dlopen、dlsym等接口函数调用该动态库。

**对于这4种方式：**

- 第1和2种，本质上是一样的，使用静态库，编译时，会将静态库的内容合并到工程代码中。

  唯一区别的是当我们拿不到第三方库的源码时，可以直接使用静态库，相当于使用一个黑盒子，静态库提供接口。

- 第3和4种方式，我们常用的是第3种方式，也就是隐性调用。但是显性调用(dlopen)一种程序插件的概念，随用随加载，不用不加载。

### 显性调用和隐性调用区别

- 隐性调用：需要**提前将动态库xxx.so 拷贝相关目录**下，不管程序是否真正使用动态库，执行前会检查该动态库，**如果检测不到动态库，会报错**。

  **程序一旦执行，会把动态库读到内存中**，而不管是否会运行到动态库部分，相当于**一刀切**。

- 显性调用：如果程序没有运行到dlopen，动态库文件xxx.so 是不需要拷贝到相关目录下的，**程序只有在执行到dlopen时，才会检查该动态库**，是一种**插件形式**，随用随调用。

  程序开始运行后，不会立刻读取动态库到内存中，而是直行道dlopen时，才会将动态库拷贝到内存中。

![image-20220717000047943](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220717000047943.png)



### 参考链接

[(20条消息) 深入分析linux下 动态库的显性调用(dlopen)和隐性调用区别_猪哥-嵌入式的博客-CSDN博客](https://blog.csdn.net/u012351051/article/details/115497369?ops_request_misc=%7B%22request%5Fid%22%3A%22165751781016782184688119%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=165751781016782184688119&biz_id=0&spm=1018.2226.3001.4187)