# 二级指针的使用场景

## 概念

![image-20220509185914583](https://hanbabang-1311741789.cos.ap-chengdu.myqcloud.com/Pics/image-20220509185914583.png)

```cpp
C = "一段内容";  //C的内容
&C = 0x00000008;  //C取地址，B的地址是0x00000008

B = 0x00000008;  //B的内容 
*B = "一段内容";  //B解引用，也就是B指针指向的C的值
&B = 0x00000004;  //B取地址，B的地址是0x00000004

*A = B = 0x00000008;  //A解引用也就是B的内容 
**A = *B = "一段内容";  //B解引用，也就是B指针指向的C的值
A = &B = 0x00000004;  //A存的是B的地址，B的地址是0x00000004
&A = 0x00000000;  //A取地址
```

## 作用

**场景：在函数外部定义一个指针q（一级），在函数内给指针赋值，函数结束后对指针q（一级）生效，那么我们就需要二级指针。**

```cpp
真实场景：如果接口外部调用方，想传入一个`HandleImp`的`mHandle`（一级指针），让接口内部给其赋值，即让`mHandle`指向`new HandleImp()`。该场景下，如果直接传入`mHandle`（一级指针）是做不到的，因为接口内部函数会拷贝一个新的指针`*tmp`，`tmp`会指向`new HandleImp()`，但这跟`mHandle`没关系，出了接口内部函数后，`mHandle`仍然一无所有。

因此采取在接口外部传入`mHandle`的地址（**即`&mHandle`，二级指针**），这样在**接口内部函数采用`**tmp`作为形参**，再对`*tmp=new HandleImp()`，（此时`*tmp`就接管着`new HandleImp()`，而`mHandle`（一级指针）此时也就代表了`new HandleImp()`），这样离开接口内部函数后，`mHandle`就获得了`HandleImp`。此外，其实上述场景在接口外部传入`mHandle`，在接口内部函数形参用**引用**接住，也是没有问题的。
    
简单来说，对于这种场景，一级指针的mHandle是无法将new HandleImp()实例从接口带出，只有二级指针可以将其带出。
```

**一级指针的实现：**

```cpp
int a= 10;
int b = 100;
int *q;

void func(int *p)
{
	cout<<"func:&p="<<&p<<",p="<<p<<endl;  // note:3
	p = &b;
	cout<<"func:&p="<<&p<<",p="<<p<<endl;  // note:4
}

int main()
{
	cout<<"&a="<<&a<<",&b="<<&b<<",&q="<<&q<<endl;  // note:1
	q = &a;
	cout<<"*q="<<*q<<",q="<<q<<",&q="<<&q<<endl;  // note:2
	func(q);
	cout<<"*q="<<*q<<",q="<<q<<",&q="<<&q<<endl;  // note:5

	return 0;
}

// 这么写有什么问题？为什么*q不等于100？我们看一下输出便知：
// &a=0032F000,&b=0032F004,&q=0032F228 note:1->a,b,q都有一个地址。
// *q=10,q=0032F000,&q=0032F228 note:2->q指向a。
// func:&p=0018FD24,p=0032F000 note:3->我们发现参数p的地址变了,跟q不一样了，是的参数传递是制作了一个副本,也就是p和q不是同一个指针,
// 但指向的地址0x0032F000(a的地址)还是不变的。
// func:&p=0018FD24,p=0032F004 note:4->p重新指向b。
// *q=10,q=0032F000,&q=0032F228 note:5->退出函数,p的修改并不会对q造成影响。
```

结论：编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 p，编译器使 p = q (但是&p != &q,也就是他们并不在同一块内存地址，只是他们的内容一样，都是a的地址)。如果函数体内的程序修改了p的内容(比如在这里它指向b)。在本例中，p申请了新的内存，只是把 p所指的内存地址改变了(变成了b的地址,但是q指向的内存地址没有影响)，所以在这里并不影响函数外的指针q。

**因此，需要二级指针：**

```cpp
int a= 10;
int b = 100;
int *q;
 
void func(int **p)  // 改动:2
{
	cout<<"func:&p="<<&p<<",p="<<p<<endl;
	*p = &b;  // 改动:3
	cout<<"func:&p="<<&p<<",p="<<p<<endl;
}
 
 
int main()
{
	cout<<"&a="<<&a<<",&b="<<&b<<",&q="<<&q<<endl;
	q = &a;
	cout<<"*q="<<*q<<",q="<<q<<",&q="<<&q<<endl;
	func(&q);  // 改动:1
	cout<<"*q="<<*q<<",q="<<q<<",&q="<<&q<<endl;

	return 0;
}
```

这里只改了三个地方，变成传二级指针。因为传了指针q的地址(二级指针`**p`)到函数,所以二级指针拷贝(拷贝的是p,一级指针中拷贝的是q所以才有问题),（拷贝了指针但是指针内容也就是指针所指向的地址是不变的）所以它还是指向一级指针`q(*p = q)`。在这里无论拷贝多少次，它依然指向q，那么`*p = &b`;自然的就是q = &b了。

## 举例

我们代码中以二级指针作为参数比较常见的是，定义了一个指针`MyClass *ptr=nullptr`，在函数内对指针赋值*ptr=malloc(...)，函数结束后指针依然有效.这个时候就必须要用二级指针作为参数func(MyClass **p,...)，一级指针为什么不行上面说了。

```c++
void  my_malloc(char **s)
{
	*s=(char*)malloc(100);
}

void  main()  
{
	char *p=nullptr;
	my_malloc(&p);
	// do something
	if(p) free(p);
}
```

### 参考链接

[(19条消息) 二级指针的作用详解_码农在新加坡的博客-CSDN博客_二级指针的作用详解](https://blog.csdn.net/majianfei1023/article/details/46629065?spm=1001.2101.3001.6661.1&depth_1-utm_relevant_index=1)